<html>
<head>
    <meta charset="utf-8" />
    <title>OpenStreetMap API</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.4.0/dist/leaflet.css" integrity="sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA==" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.4.0/dist/leaflet.js" integrity="sha512-QVftwZFqvtRNi0ZyCtsznlKSWOStnDORoefr1enyq5mVL4tmKB3S/EnC3rRJcxCPavG10IcrVGSmPh6Qw5lwrg==" crossorigin=""></script>
    <style>
        #Demo {
            width: 100%;
            height: 100%;
        }

        .map-popup-content {
            width: 300px;
        }

            .map-popup-content .left {
                float: left;
                width: 40%;
            }

                .map-popup-content .left img {
                    width: 100%;
                    height: 100px;
                    margin: -15px 0 -15px -20px;
                    border-radius: 12px;
                }

            .map-popup-content .right {
                float: left;
                width: 60%;
            }

        .clearfix {
            clear: both;
        }
    </style>
</head>
<body>
    <div id="Demo"></div>
    <h1>Searching</h1>
    <button>submit</button>
</body>


</html>

<script>
    var mapObj = null;
    var defaultCoord = [15, 107]; // coord mặc định
    var zoomLevel = 13;
    var mapConfig = {
        
        center: [15,107], // vị trí map mặc định hiện tại
        zoom: zoomLevel, // level zoom
    };

    window.onload = function () {
        // init map
        mapObj = L.map('Demo', mapConfig);

        // add tile để map có thể hoạt động, xài free từ OSM
        L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(mapObj);

        // tạo marker
        var popupOption = {
            className: "map-popup-content",
        };
        
    };

    function addMarker(coord, popupContent, popupOptionObj, markerObj) {
        if (!popupOptionObj) {
            popupOptionObj = {};
        }
        if (!markerObj) {
            markerObj = {};
        }

        var marker = L.marker(coord, markerObj).addTo(mapObj); // chơi liều @@
        var popup = L.popup(popupOptionObj);
        popup.setContent(popupContent);

        // binding
        marker.bindPopup(popup);

        return marker;
    }

    //ShortestPath
    function shortestPath(edges, numVertices, startVertex) {
        var done = new Array(numVertices);
        done[startVertex] = true;
        var pathLengths = new Array(numVertices);
        var predecessors = new Array(numVertices);
        for (var i = 0; i < numVertices; i++) {
            pathLengths[i] = edges[startVertex][i];
            if (edges[startVertex][i] != Infinity) {
                predecessors[i] = startVertex;
            }
        }
        pathLengths[startVertex] = 0;
        for (var i = 0; i < numVertices - 1; i++) {
            var closest = -1;
            var closestDistance = Infinity;
            for (var j = 0; j < numVertices; j++) {
                if (!done[j] && pathLengths[j] < closestDistance) {
                    closestDistance = pathLengths[j];
                    closest = j;
                }
            }
            done[closest] = true;
            for (var j = 0; j < numVertices; j++) {
                if (!done[j]) {
                    var possiblyCloserDistance = pathLengths[closest] + edges[closest][j];
                    if (possiblyCloserDistance < pathLengths[j]) {
                        pathLengths[j] = possiblyCloserDistance;
                        predecessors[j] = closest;
                    }
                }
            }
        }
        return {
            "startVertex": startVertex,
            "pathLengths": pathLengths,
            "predecessors": predecessors
        };
    }

    function constructPath(shortestPathInfo, endVertex) {
        var path = [];
        while (endVertex != shortestPathInfo.startVertex) {
            path.unshift(endVertex);
            endVertex = shortestPathInfo.predecessors[endVertex];
        }
        return path;
    }

</script>